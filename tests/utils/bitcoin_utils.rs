use bitcoin::bip32::{ChildNumber, DerivationPath, Xpub};
use bitcoin::secp256k1::{PublicKey, Secp256k1, SecretKey};
use bitcoin::{bip32::Xpriv, Address, Network, ScriptBuf};
use bitcoin::{PublicKey as BitcoinPublicKey, WPubkeyHash};
use bitcoind::AddressType;
use serde_json::{json, Value};
use std::str::FromStr as _;

pub struct UserInfo {
    pub address: Address,
    pub script_pubkey: ScriptBuf,
    pub private_key: SecretKey,
    pub public_key: PublicKey,
    pub bitcoin_public_key: BitcoinPublicKey,
    pub wpkh: WPubkeyHash,
}

pub struct BTCTestContext<'a> {
    client: &'a bitcoind::Client,
    master_key: Xpriv,
    account_index: u32,
}

impl<'a> BTCTestContext<'a> {
    pub fn new(client: &'a bitcoind::Client) -> Result<Self, Box<dyn std::error::Error>> {
        let master_key = Self::get_master_key_of_regtest_node(client)?;
        Ok(BTCTestContext {
            client,
            master_key,
            account_index: 0,
        })
    }

    pub fn setup_account(&mut self) -> Result<UserInfo, Box<dyn std::error::Error>> {
        let address = self
            .client
            .get_new_address_with_type(AddressType::Legacy)
            .unwrap()
            .address()
            .unwrap();

        let address = address.require_network(Network::Regtest).unwrap();

        // Get address info for Bob
        let address_info: Value = self
            .client
            .call("getaddressinfo", &[address.to_string().into()])?;

        // Extract the scriptPubKey from the result
        let script_pubkey_hex = address_info["scriptPubKey"]
            .as_str()
            .expect("scriptPubKey should be a string");

        let script_pubkey =
            ScriptBuf::from_hex(script_pubkey_hex).expect("Failed to parse scriptPubKey");

        // Initialize secp256k1 context
        let secp = Secp256k1::new();

        // Derive child private key using path m/44h/1h/0h
        let path = "m/44h/1h/0h".parse::<DerivationPath>().unwrap();
        let child = self.master_key.derive_priv(&secp, &path).unwrap();
        let xpub = Xpub::from_priv(&secp, &child);

        // Generate P2PKH address at m/0/{account_index}
        let zero = ChildNumber::Normal { index: 0 };
        let index = ChildNumber::Normal {
            index: self.account_index,
        };
        let public_key = xpub.derive_pub(&secp, &[zero, index]).unwrap().public_key;
        let bitcoin_public_key: BitcoinPublicKey = BitcoinPublicKey::new(public_key);
        let derived_address = Address::p2pkh(bitcoin_public_key, Network::Regtest);

        // Verify that the address is the same as the one generated by the client
        assert_eq!(address, derived_address);

        // Get private key for first P2PKH address
        let private_key: SecretKey = child
            .derive_priv(&secp, &DerivationPath::from(vec![zero, index]))
            .unwrap()
            .private_key;

        let wpkh: WPubkeyHash = bitcoin_public_key
            .wpubkey_hash()
            .expect("key is compressed");

        self.account_index += 1;

        Ok(UserInfo {
            address,
            script_pubkey,
            private_key,
            public_key,
            bitcoin_public_key,
            wpkh,
        })
    }

    fn get_master_key_of_regtest_node(
        client: &bitcoind::Client,
    ) -> Result<Xpriv, Box<dyn std::error::Error>> {
        let descriptors: Value = client.call("listdescriptors", &[true.into()])?;

        let p2pkh_descriptor = descriptors["descriptors"]
            .as_array()
            .unwrap()
            .iter()
            .find(|descriptor| descriptor["desc"].as_str().unwrap().contains("pkh"))
            .expect("No P2PKH descriptor found");

        let desc = p2pkh_descriptor["desc"].as_str().unwrap();
        let parts: Vec<&str> = desc.split('/').collect();
        let master_key_str = parts[0].replace("pkh(", "").replace(")", "");

        let master_key = Xpriv::from_str(&master_key_str).unwrap();

        Ok(master_key)
    }

    pub fn get_utxo_for_address(
        &self,
        address: &Address,
    ) -> Result<Vec<serde_json::Value>, Box<dyn std::error::Error>> {
        let min_conf = 1;
        let max_conf = 9999999;
        let include_unsafe = true;
        let query_options = json!({});

        let unspent_utxos: Vec<serde_json::Value> = self.client.call(
            "listunspent",
            &[
                json!(min_conf),
                json!(max_conf),
                json!(vec![address.to_string()]),
                json!(include_unsafe),
                query_options,
            ],
        )?;

        // Verify UTXO belongs to the address and has the correct amount
        for utxo in unspent_utxos.iter() {
            assert_eq!(
                utxo["address"].as_str().unwrap(),
                address.to_string(),
                "UTXO doesn't belong to the address"
            );
        }

        Ok(unspent_utxos)
    }
}
